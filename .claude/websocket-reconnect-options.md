# WebSocket重连方案设计

## 问题分析
讯飞语义请求每次点击"发送语义查询"后，WebSocket会断开连接，用户需要手动点击"重新连接"。

## 三个可行方案

### 方案A：查询前自动重连 ⭐⭐⭐⭐⭐
**核心思路**：不主动维护连接，每次发送查询前检查状态，断开则自动重连

**优点**：
- ✅ 代码最简单可靠
- ✅ 状态管理清晰
- ✅ 避免复杂的状态标志
- ✅ 易于调试和维护

**缺点**：
- ⚠️ 每次查询会有1-2秒连接延迟
- ⚠️ 每次查询都要重连，资源消耗略大

**实现**：
```typescript
async sendQuery() {
  // 查询前检查连接
  if (!this.isConnected()) {
    await this.connect()  // 自动重连
  }
  // 发送查询
}
```

---

### 方案B：智能保持连接 ⭐⭐⭐
**核心思路**：维护连接状态，关闭时自动重连，但逻辑简单化

**优点**：
- ✅ 查询响应快（连接已存在）
- ✅ 适合频繁查询场景

**缺点**：
- ⚠️ 需要状态管理
- ⚠️ 可能出现竞态条件
- ⚠️ 调试困难

**实现**：
```typescript
// onclose时自动重连，但仅重连1次
onclose() {
  if (!this.isManualDisconnect) {
    this.connectOnce()  // 简单重连一次
  }
}
```

---

### 方案C：查询后主动断开 ⭐⭐
**核心思路**：每次查询完成后主动断开，下次查询重新建立连接

**优点**：
- ✅ 逻辑最简单
- ✅ 资源及时释放
- ✅ 避免连接长时间占用

**缺点**：
- ⚠️ 用户感觉"断开"，体验稍差
- ⚠️ 每次都要重连

**实现**：
```typescript
async sendQuery() {
  await this.connect()
  // 发送查询
  // 查询完成后主动断开
  this.disconnect()
}
```

---

## 推荐方案：方案A

### 原因
1. **最稳定可靠** - 无复杂状态管理，避免bug
2. **满足需求** - 用户无需手动重连，自动化完成
3. **易于维护** - 代码清晰，后续迭代容易
4. **成本低** - 开发快，测试简单

### 实施步骤
1. 修改 `xunfei-api.service.ts` 的 `sendQuery` 方法
2. 查询前检查 `isConnected()` 状态
3. 如果断开，自动调用 `connect()` 重连
4. 然后发送查询
5. 不主动断开连接，让服务端决定何时关闭

### 预期效果
- 用户体验：点击查询后自动完成，无需手动操作
- 性能：查询前1-2秒连接时间
- 稳定性：95%+，简单逻辑保证可靠性
